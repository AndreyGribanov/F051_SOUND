#include "stm32f0xx.h"
#include "delay.h"


#define READ  0x03//команда чтения памяти. После нее надо передать 3 байта адреса с которого вы хотите читать. 
                   //После память будет считываться до тех пор пока вы не перестанете подавать тактирующие сигналы по CLK 
									 //линии SPI (считываются все адреса подряд, а при достижении max адреса памяти микросхемы — 
									  //адрес становится равным нулю — кольцевой буфер). 

#define set_CS GPIOB->BSRR |= GPIO_BSRR_BR_6//выбор кристалла активен(лог 0)
#define reset_CS GPIOB->BSRR |= GPIO_BSRR_BS_6;//выбор кристалла не активен(лог 1)


extern unsigned char DAC_Buff[512];//буфер, в который считывает обработчик прерываний
//extern-указывает на внешнюю переменную(в main.c компилятор уже выделил под нее место в памяти) и не выделяет память
uint16_t i = 0;//глобальная,индекс массива в который БУДЕМ читать


void spi_conf()//настройка spi для F051
{	
  //Включаем тактирование SPI1 и GPIOB
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
	
  RCC->APB2ENR |= RCC_APB2ENR_SPI1EN ;//в h файле шина разделена на 2,в datasheet она одна
	
	  //Настраиваем выводы SPI1:
	//PB6-FCS-выбор кристалла
	 GPIOB->MODER &=~ GPIO_MODER_MODER6;//сброс
	 GPIOB->MODER |= GPIO_MODER_MODER6_0;//01-output,00-input(after reset),10-AF,11-analog.
	 GPIOB->OTYPER &=~ GPIO_OTYPER_OT_6;//1-открытый коллектор,0-двухтактный(после сброса)
	 GPIOB->OSPEEDR |=GPIO_OSPEEDER_OSPEEDR6_1;//10-высокая скорость 10МГц,01-2МГц,11-50Мгц
	 GPIOB->BSRR |= GPIO_BSRR_BS_6;//выбор кристалла неактивен(лог 1)
	
  //PB3-SCK: 
   GPIOB->MODER &=~ GPIO_MODER_MODER3;//сброс
	 GPIOB->MODER |= GPIO_MODER_MODER3_1;//01-output,00-input(after reset),10-AF,11-analog.
	 GPIOB->AFR[0]  &=~ GPIO_AFRL_AFSEL3 ;//сброс,AF0 -SPI1
	 GPIOB->OSPEEDR |=(GPIO_OSPEEDER_OSPEEDR3_1|
	                  GPIO_OSPEEDER_OSPEEDR3_0);//10-высокая скорость 10МГц,01-2МГц,11-50Мгц
		  
  //PB4-MISO:
	 GPIOB->MODER &=~ GPIO_MODER_MODER4;//сброс
	 GPIOB->MODER |= GPIO_MODER_MODER4_1;//01-output,00-input(after reset),10-AF,11-analog.
	 GPIOB->AFR[0]  &=~ GPIO_AFRL_AFSEL4 ;//сброс,AF0 -SPI1
   /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 //GPIOB->AFR[0]  |= (GPIO_AFRL_AFSEL4_2 | GPIO_AFRL_AFSEL4_0);//AF=5 -SPI1	 
	 //GPIOA->AFR[0] |=(1<<(16)) |(1<<(18));-ВАРИАНТ НАВЕРНЯКА,H ФАЙЛ НЕ ИМЕЕТ АДРЕСОВ ПОБИТНОЙ НАСТРОЙКИ GPIO_AFRL_AFSEL4_0
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
	
  //PB5-MOSI:
	 GPIOB->MODER &=~ GPIO_MODER_MODER5;//сброс
	 GPIOB->MODER |= GPIO_MODER_MODER5_1;//01-output,00-input(after reset),10-AF,11-analog.
	 GPIOB->AFR[0]  &=~ GPIO_AFRL_AFSEL5 ;//сброс,AF0 -SPI1
	 GPIOB->OSPEEDR |=(GPIO_OSPEEDER_OSPEEDR5_1|
	                  GPIO_OSPEEDER_OSPEEDR5_0);//10-высокая скорость 10МГц,01-2МГц,11-50Мгц
		
   SPI1->CR2 |= SPI_CR2_FRXTH;  //Генерация rxne при наличии 8 бит в FIFO
	
	SPI1->CR2 &=~ SPI_CR2_DS;
	SPI1->CR2 |= (SPI_CR2_DS_2|SPI_CR2_DS_1|SPI_CR2_DS_0);//ДЛИНА 8 БИТ
	
   SPI1->CR1 &= ~SPI_CR1_LSBFIRST ;    //MSB передается первым,при =1-LSB передается первым(младший)
   SPI1->CR1 |=SPI_CR1_SSM ;         //Программное управление ведомым сигнал NSS заменяется значением бита SSI.
   SPI1->CR1 |=SPI_CR1_SSI ;         //SSi в высоком состоянии
   SPI1->CR1 |=(SPI_CR1_BR_2);//|SPI_CR1_BR_1);//|SPI_CR1_BR_0) ;//SPI_CR1_BR_2|0x04Скорость передачи: F_PCLK/4,когда 0 F_PCLK/2
   SPI1->CR1 |=SPI_CR1_MSTR ;        //Режим Master (ведущий)
   SPI1->CR1 &=~(SPI_CR1_CPOL | SPI_CR1_CPHA); //Режим работы SPI: 0
	 SPI1->CR2 |= SPI_CR2_RXNEIE;
	 SPI1->CR1 |= SPI_CR1_SPE; //Включаем SPI
}	//end spi_conf
//*******************************************************************************************************************

void SPI_Write(uint8_t data)//
{
  while(!(SPI1->SR & SPI_SR_TXE)){}// ждем,когда можно будет загружать данные в DR
                                    // TXE флаг опустошения буфера передачи
 
 *(uint8_t *)&(SPI1->DR) = data;//По умолчанию доступ к SPIx-›DR 16бит!!проявилось только в F051,иначе,data будут старшими и в итоге ff00
	//	SPI1->DR = data;//заполняем буфер передатчика/так было в f103,f407
	while(SPI1->SR & SPI_SR_BSY){}//ждем окончания передачи(необязательное условие)
 
}
//*********************************************************************************************************************
	void SPI1_IRQHandler(void)//обработчик прерываний 
{
 if (SPI1->SR & SPI_SR_RXNE)//если пришли данные(поднят флаг RXNE)..,сброс в F4 после чтения DR
	{
		DAC_Buff[i] = SPI1->DR;
		i++;
		if (i==512) i=0;
	}//Очистка бита RXNE выполняется при чтении регистра SPI_DR.
	 }
//************************************************************************************************************************

void Read_SPI(uint16_t N)//чтение в буфер N количества данных,фактически тактирует SPI,а обработчик читает в буфер 
{ 
	for(uint16_t n=0;n<N;n++)//когда uint8_t =256,то оно воспринимается как 0
	{	SPI_Write(0xff);	}
	
	
}//end Read_SPI
//***********************************************************************************************************************

void Read_En(void)//процедура перевода в режим чтения микросхемы
{
  set_CS;
	delay_us(500);
	//delay_us(1000);
	SPI_Write(READ);//0x03,команда чтения флеш	
	SPI_Write(0);//старший байт номера страницы
	SPI_Write(0);//младший байт номера страницы	
	SPI_Write(0);//номер первого байта
  i=0;//читать начинаем в начало буфера

}

